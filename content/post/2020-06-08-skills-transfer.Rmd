---
title: "Skills Transfer"
author: "Kobus Huisamen"
date: '2020-06-08'
draft: yes
slug: skills-transfer
categories:
- skills
- clusterering
tags: ILS
---

```{r}

```


# This is a sample

The current.....


## Background

A support concept describe the flow of activities and items. This can be from where a system is operating to where maintenance is performed and spares are located. Normally, basic maintenance happens at the organization on the system. Intermediate maintenance facilities is located close by with more skilled personnel and better equipped workshops. Anything beyond this goes to highly skilled personnel typically at manufacturers facilities.

Most support organizations face a shortage of some skills some time. Or, some organizations cannot afford multiple levels of support. When facing these situations the approach is often to reduce the support levels and build capacity in-house.

<!-- TODO Edit from here -->
To reduce the support levels and build the in-house capacity is not necessary the cheaper option. The reason for repairing equipment at other facilities is because the task is considered beyond the skill level or tools available in-house. Acquiring these specialized skills and tools is expensive.

There are often tasks which use the same tools but  But there is also  What Meaning it's resources such as specialized skills and equipment that is not available in-house. It's these resources that is the distinguishing factor where the task will happen.

Some In my experience there is always a degree of overlap  characteristic that If resources between the different maintenance levels are very unique then there is a The similarity 

We will explore how will you go about building this in-house capacity 

## Problem

How can we identify where to start, which tasks should we train the maintainer on.
to focus on when we can transfer (see some lessons in skill transfer from informs conference)

## Approach

Group tasks based on the similarity of resources. Resources can be anything you need to do the task, for example the screw driver, multimeter, spanners, the spares and the skills.  


How R helped to solve this problem

Where can we use this 

Sample code and illustration of application of this approach.

## Clustering

We are using clustering k-means --- explain how it works



## Case Study

Link to a shiny app where user can change the number of support levels (cluster)
Generate example data that use skills etc for maintenance tasks


# Create Sample Data

For this we will create a list of tasks and then link all the resources we need for the task.

  * Parts
  * Tools
  * Skills

Depth of maintenance range from A - D. 
We will pre-assign skills to depth of maintenance, that way we know some skills are normally associated with a specific task complexity.

Lets assume the current maintenance policy is based on a three level support structure

  * LOR-1 Organisation A, B
  * LOR-2 Intermediate C
  * LOR-3 OEM D

*We experiencing a shortage of skills at LOR-2 and want to know which of the depth C maintenance tasks can we transfer to LOR1.*

You cannot give somebody tools and expect them to know what to do with it, but have to teach to transfer skills. Sometimes it takes time to build up the experience.

```{r make_sample_data}
library(dplyr)
#Generate a task list with random complexity depth
tasks <- 100
task_list <- data.frame(task = paste("Task", seq.int(1,to = tasks,  by = 1)),
                        task_depth = sample(x = c('A','B','C','D'), size = tasks, replace = TRUE))

# Create Resource list
parts <- 50
parts_list <-  paste0("Part-", seq.int(1,to = parts,  by = 1))

tools <- 20
tools_list <-  paste0("Tool-", seq.int(1,to = tools,  by = 1))

skills <- 10
skills_list <-  paste0("Skill-", seq.int(1,to = skills,  by = 1))
skills_level <- sample(x = c('A','B','C','D'), size = skills, replace = TRUE)

#  Link Tasks and Resources


task_resources <- NULL
set.seed(31052020)
for (task in task_list$task) {
  
  #id task complexity
  depth <- task_list[task_list$task==task,'task_depth'] 
  # pick items
  pick_list <- data.frame(task = task, 
                          resource = unique(sample(x = parts_list, size = sample(1:10,1), replace = TRUE)),
                          resource_type = 'part')
  # add pick list to the data
  task_resources <- rbind(task_resources, pick_list)
  
  
  # pick tools
  pick_list <- data.frame(task = task, 
                          resource = unique(sample(x = tools_list, size = sample(1:5,1), replace = TRUE)),
                          resource_type = 'tool')
  # add pick list to the data
  task_resources <- rbind(task_resources, pick_list)
  
  # pick skills
  skills_pick <- skills_list[skills_level==ifelse(depth %in% skills_level, as.character(depth), skills_level[1])]
  
  pick_list <- data.frame(task = task, 
                          resource = unique(sample(x = skills_pick, size = sample(1:5,3), replace = TRUE)),
                          resource_type = 'skill')
  
  # add pick list to the data
  task_resources <- rbind(task_resources, pick_list)
  
}
head(task_resources)
pander::pandoc.table(head(table(task_resources[,c("task","resource_type")])))
#TODO: Show some sample with table
```


So now we have tasks and resources linked.

```{r explore_the_sample_data}
# normalise the task resource list data
tn <- left_join(x = task_list,
                y = task_resources,
                by = "task")

# get most significant resources by type for each repair depth
rt <- tn %>% 
  group_by(task_depth, resource_type, resource) %>% 
  tally() %>% 
  top_n(n = 1,wt = n)
```

What do we use a lot at the different levels of repair



```{r}
mm <- model.matrix(task ~., data = task_resources)[,-1]
# heatmap(mm)

#TODO Explain this:
library(dplyr)
mm.grp <-  mm %>% 
  as.data.frame() %>%
  mutate(task = task_resources$task) %>%
  group_by(task) %>%
  summarise_all(sum)
#because we sum the total res qty we will need to scale the data for the heatmap
mm.grp.scaled <- scale(mm.grp[,!(colnames(mm.grp)=='task')])
```

The number of clusters we need relates to the number of support levels we want. In typical support environments we will find the basic tasks such as cleaning, checking and minor adjustments are done at the operational level by operators or maintainers. Minor repairs are done at the workshop by more experienced technical personnel. In some instances there is another two levels to cater for specialized diagnostics and upgrades or modifications.  The latter normally done by specialised engineers. In this example let's say we have three levels.

## Identifying the tasks

Back to our problem. 
*We experiencing a shortage of skills at LOR-2 and want to know which of the depth C maintenance tasks can we transfer to LOR1.* 
Rephrase the problem in terms of the cluster analysis we can say. 
Which depth C tasks appear in cluster 1

```{r}
#Cluster and dimension reduction
set.seed(12356)
# kmeansObj <- kmeans(mm.grp[,-1], 10)
kmeansObj <- kmeans(mm.grp.scaled, 3)

# add cluster to task list
mk <- cbind(mm.grp, cluster = kmeansObj$cluster, depth = task_list$task_depth)


# Data is standardised before principal component analysis with stand=TRUE
factoextra::fviz_cluster(object = kmeansObj, data = mm.grp[,-1], ellipse.type = "norm", stand = TRUE)
```

Cluster and task complexity
```{r}
# table(mk$cluster, mk$depth)
heatmap(table(mk$cluster, mk$depth))
# heatmap(as.matrix(mk[,-1]))
# heatmap(table(mk$cluster, mk$`task_resources$task`))

# heatmap(mm[,-1])
```

## Levels Of Repair
We are looking for tasks that 
Look from the cluster perspective as that represents our repair levels in which we want to find commonality.

```{r}
# plot cluster and depth
# plot the depth with fraction of cluster

library(ggplot2)
ggplot(mk) +
 aes(x = cluster, fill = depth) +
 geom_bar() +
 scale_fill_hue() +
 theme_minimal()
```
Let's look at the cluster range of the tasks from a depth perspective.
```{r}
table(mk[,c("cluster","depth")])
```


Let's look at the tasks that are at the same complexity but appear to be similar in resources.
```{r}
# find the most significant overlap = commonality
# t1 <- table(mk[,c("cluster","depth")])

library(dplyr)
t1 <- mk %>% 
  select(cluster, depth) %>% 
  group_by(cluster) %>% 
  summarise(cluster_range = length(unique(depth)))

slct_complex <- t1$cluster[t1$cluster_range==max(t1$cluster_range)]
# Find which complexity is the most significant at this level, once
skilled_for <-  names(which.max(table(mk[,c("cluster","depth")])[slct_complex,]))

# What other tasks can we do at this level
cat("Cluster", slct_complex, "have the widest range of task complexity,", "and is mainly skilled for maintenance at depth", skilled_for)
```

Select the tasks with complexity 
```{r}
slct_tasks <- mk[mk$cluster==slct_complex,"task"]
task_resources[task_resources$task %in% slct_tasks,]

# create normalised list of tsks, resources, cluster and depth
d <- cbind(task_list,cluster = kmeansObj$cluster) %>% 
  left_join(task_resources) 
```


```{r}
# select tasks for selected cluster
d_slct <- d %>% 
  filter(task %in% slct_tasks) %>% 
  filter(resource_type == "skill") %>% 
  mutate(task = paste0(task," (", task_depth, ")")) %>% 
  droplevels()

# make matrix of this list for heatmap
heatmap(table(d_slct$task_depth, d_slct$resource))
# factoextra::fviz_ca()
# table the resources and focus on skills but show what tools needed to, what makes them close
```
As expected we see skills are closely related to the complexity of the tasks in this cluster. But, remember these tasks are clustered together, therefore there must be some other commonality. Let's look at the parts and tools. 
<!-- Deeper dive into the tasks and the resources that make them family.  -->
Which parts are common
```{r}
# select tasks for selected cluster
d_slct <- d %>% 
  filter(task %in% slct_tasks) %>% 
  filter(resource_type == "part") %>% 
  mutate(task = paste0(task," (", task_depth, ")")) %>% 
  droplevels()

# make matrix of this list for heatmap
heatmap(table(d_slct$task_depth, d_slct$resource))
```
Which tools
```{r}
# select tasks for selected cluster
d_slct <- d %>% 
  filter(task %in% slct_tasks) %>% 
  filter(resource_type == "tool") %>% 
  mutate(task = paste0(task," (", task_depth, ")")) %>% 
  droplevels()

# make matrix of this list for heatmap
heatmap(table(d_slct$task_depth, d_slct$resource))
```

Here we see a lot of commonality.

What we see here is that the skills are closely related to complexity, but they seem to use similar tools and spares.  In real world example below we see similar pattern.

```{r}
# Obfuscated real world example here.
```


This means that in some cases where we have limited personnel, we might have another support level where the tools and spares already exist, all that is lacking is getting the competencies across. For this a training and development plan can help.  The cluster analysis can help to identify exactly which tasks needs to be in the training and development plan.


What we see in heatmap.  Depth A is mainly cluster 1, Depth C has heavy presence in cluster 1 and 2. Depth D is mainly cluster 3. Depth B is almost equally distributed in cluster 2 and 3. 

We can see that there is an opportunity at depth B to transfer skills capability between levels 2 and three. We can identify the tasks for this opportunity. (Skill 3 is common, which mean parts and tools migh be different.)


```{r}
# Task 16
task_resources[task_resources$task %in% c("Task 16", "Task 17"),]
```



Add cluster id to task list

```{r}
task_list$cluster <-  kmeansObj$cluster
```

__Why is that we see some tasks have different complexity but in the same cluster?__
Sample two tasks from same cluster, but different complexity and view difference in resources.

```{r}
# Use kmeansObj$centers to show distance betwwen 
```
